#!/usr/bin/env wish

wm title . "RSTTool"
proc Quit {} {exit}
wm protocol . WM_DELETE_WINDOW Quit
frame .segmentframe

######################################
# Set variables
set LOGIN marcu
set PRINTER ps9b_s
set MAX_CLICK_DELAY 120
set PLATFORM $tcl_platform(platform)
set DIR [file dirname [info script]]
set DOT_EXISTS NO
# set DOT_EXISTS YES
# set DOT    "/nfs/etg/mediadoc/graphviz/src/cmd/dot/dot"

set SRC     [file join $DIR Source]
set LIBRARY [file join $SRC Library]
set RELS    [file join $DIR Relation-Sets]
set HELP    [file join $DIR Help]

set LIB_FILES {delete.tcl dialog1.tcl draw.tcl node.tcl tcl-extens.tcl tkfbox.tcl \
		   time.tcl toolbar.tcl}
set SRC_FILES {Segmenter Structurer Draw EditRelations Layout Make Print Helper}
set EDITOR_FILES {new.tcl lifo.tcl textundo.tcl Editor1.tcl}

# set global variables
set x1 {}
set x2 {}
set disco_node {}
set collapsed_nodes {}
set step_file {}
set currentfile {}
set size_factor 130
set actual_sec 0
set last_date {}
set begin_date {}
set cancelled 0
set editor_mode normal
set list_of_toplevels {}
set peruse_or_edit {}
set trgdir rst
set trgfname /dev/null
set save_fmt raw
set save_func "save-${save_fmt}"
set load_func "load-${save_fmt}"
set savenum 0
set crntMsgId {};	# id of the current message
set crntMsgTxt "";	# text of the current message
set prntMsgId {};	# id of the parent message
set prntMsgTxt "";	# text of the parent message
set msgQueue {};	# queue of messages not yet visited
set msgPrevQueue {};	# queue of visited messages
set theRoots {};	# id's of messages which start new discussions
set theRootIdx -1;	# index of current discussion
set erased_nodes {};	# list of erased nodes
array set visible_nodes {};    # list of nodes which are visible in RST editor
array set msgs2extnid {}; # array mapping pairs of message ids
			  # (prnt_msg_id,chld_msg_id) to the id of nodes which
			  # connect two messages
array set msgid2nid {};	  # mapping from message ids to ids of internal nodes
			  # belonging to that message
array set help {};
set helpmenu {relation_defs interface}

######################################
# Load modules
proc load-module {Path Files} {

    foreach ifile $Files {
	puts stderr "Loading $ifile"
	source [file join $Path $ifile]
    }
}

load-module $LIBRARY $LIB_FILES
load-module $LIBRARY $EDITOR_FILES
load-module $SRC $SRC_FILES

load-relations [file join $RELS Relations]
load-relations [file join $RELS ExtRelations] 1
load_abbreviations [file join $RELS abbreviations]
load_help

install-segmenter
reset-rst
set-mode link

######################################
# Set appearance
tk_setPalette background gray35 foreground white \
    highlightbackground gray10 activebackground white activeforeground red
catch {source $env(HOME)/.wishrc}

.editor.text configure -bg white
.editor.textPrnt configure -bg white
.editor.text configure -fg black
.editor.textPrnt configure -fg black

set old_clr purple;
.editor.text tag configure old -foreground $old_clr
.editor.text tag configure next -foreground black
.editor.text tag configure new -foreground DimGray
.editor.text tag lower new
.editor.text tag configure notes -foreground black
.editor.text tag configure my_sel -background yellow

.editor.textPrnt tag configure old -foreground $old_clr

######################################
# Set bindings

# load/save functions
bind all <Control-o> {open-file}
bind all <Control-s> {$save_func}
bindtags .editor.text {all .editor.text Text . UndoBindings(1)}

# node creation functions
bind .editor.text <ButtonRelease-1> {
    create-a-node-here really
}

# operations on node
.editor.text tag bind bmarker <Control-B1-Motion> {move-node .editor.text %x %y %X %Y}
.editor.text tag bind bmarker <Control-Alt-ButtonPress-1> {delete-node .editor.text %x %y}

######################################
# Methods
proc set-file-name { file_type { other_file {} } {create_dir {1}}} {
    global currentfile trgdir
    global PLATFORM LOGIN

    if {$other_file == {}} {
	set other_file $currentfile
    }

    set dirname [file join $trgdir $file_type]
    if {$create_dir && ![file exists $dirname]} {file mkdir $dirname}

    set basename [file rootname [file tail $other_file]]
    if {$PLATFORM == "unix"} {
	set uname [exec whoami]
    } else {
	set uname $LOGIN
    }
    return [file join $dirname "$basename.$uname"]
}

proc open-step-file {} {
    global step_file currentfile

    set mystepfile [set-file-name step]
    set step_file [open "$mystepfile" w 0644]
}

proc peruse-step-file {} {
    global step_file currentfile
    global PLATFORM

    set mystepfile [set-file-name step]
    set mystepfile [split $mystepfile .]
    set mystepfile [lindex $mystepfile 0].[lindex $mystepfile 1]

    if {$PLATFORM == "unix"} {
	set dircontents [exec ls $currentfile.rst/]
	set dircontents [split $dircontents "\n"]
    } else {
	set dircontents [exec command.com /c dir $currentfile.rst]
    }
    set stepfile_list {}
    set index [lsearch $dircontents $mystepfile.*]
    while {$index != -1} {
	lappend stepfile_list [lindex $dircontents $index]
	set dircontents [lreplace $dircontents $index $index]
	set index [lsearch $dircontents $mystepfile.*]
    }
    if {[lindex $stepfile_list 1] != {}} {
	set mystepfile [popup-choose-from-list "$stepfile_list" 0 0 NOcancel]
    } else {
	set mystepfile [lindex $stepfile_list 0]
    }

    set step_file [open $currentfile.rst/$mystepfile r]
}

proc save-step {the_step} {
    global step_file currentfile
    puts $step_file "$the_step"
    flush $step_file
}

proc close-step-file {} {
    global step_file
    if {"$step_file" != {} } {
	close $step_file
    }
}

proc reload-it-all {filename} {
    global step_file currentfile savenum last_text_node_id
    global new_node_text newest_node theText usedText

    set new_node_text {}
    set theText {}
    set usedText {}
    reset-rst

    load-file $filename
    close-step-file

    set step_file [open $currentfile.step r]

    set my_list {}
    set i 0
    while {[gets $step_file my_command] >= 0} {
	lappend my_list $my_command
    }
    close-step-file
    open-step-file
    set savenum 0
    set last_text_node_id 0
    foreach my_command $my_list {
	save-step "$my_command"
	if {[regexp {^autolink_nodes} $my_command]} {
	    incr savenum
	} elseif {[regexp {^create-a-node-here} $my_command]} {
	    incr savenum
	    incr last_text_node_id
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^add-this-to-a-node} $my_command]} {
	    incr savenum
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^nextSentence} $my_command]} {
	    regsub really $my_command fake my_command
	    eval $my_command
	}
    }
    reset-rst
    if { $savenum > 0 } {
	load-rst $savenum
	set newest_node $last_text_node_id
    } else {
	reset-rst
	redisplay-net
    }
    editor-message "loaded $currentfile.$savenum"
}

proc undo_by_reload { {really {1}} } {
    global step_file currentfile savenum last_text_node_id
    global new_node_text newest_node theText usedText collapsed_nodes
    global editor_mode disco_node erased_nodes

    set new_node_text {}
    set theText {}
    set usedText {}
    set collapsed_nodes {}
    set editor_mode normal

    bind .editor.text <Control-ButtonRelease-1> {add-this-to-a-node really}
    bind .editor.text <ButtonRelease-2> {add-this-to-a-node really}
    bind .editor.text <ButtonRelease-1> {create-a-node-here really}

    if {$really == 1} {
	save-step #undo
	#load text
    }

    reload-current-file

    #3rd case - allows perusal of someone else's structure
    if {$really != 2} {
	close-step-file
	open-step-file
    } else {
	peruse-step-file
    }

    set my_list {}
    set i 0
    while {[gets $step_file my_command] >= 0} {
	lappend my_list $my_command
	if {[regexp {^#undo} $my_command]} {
	    set j $i
	    set my_list [lreplace $my_list $j $j "#UNDID"]
	    while { $j > 0 } {
		incr j -1
		set my_test [lindex $my_list $j]
		if {[regexp {^#} $my_test]} {
		} else {
		    set my_list [lreplace $my_list $j $j "#$my_test"]
		    if {[regexp {^collapsed_nodes} $my_test]} {
		    } else {
			set j 0
		    }
		}
	    }
	}
	incr i
    }
    if {$really != 2} {
	close-step-file
	open-step-file
    }
    set savenum 0
    set erased_nodes {}
    set last_text_node_id 0
    foreach my_command $my_list {
	if {$really != 2} {
	    save-step "$my_command"
	}
	if {[regexp {^autolink_nodes} $my_command]} {
	    incr savenum
	    set disco_node {}
	    set-mode nothing
	} elseif {[regexp {^disconnect_node} $my_command]} {
	    incr savenum
	    set method [lindex $my_command 2]
	    if {$method == "disconnect"} {
		set disco_node {}
		set-mode nothing
	    } else {
		#method == modify
		set disco_node [lindex $my_command 1]
		set-mode link
	    }
	    lappend erased_nodes $disco_node
	} elseif {[regexp {^create-a-node-here} $my_command]} {
	    incr savenum
	    incr last_text_node_id
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^add-this-to-a-node} $my_command]} {
	    incr savenum
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^nextSentence} $my_command]} {
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^showText} $my_command]} {
	    regsub really $my_command fake my_command
	    eval $my_command
	} elseif {[regexp {^collapsed_nodes} $my_command]} {
	    eval "set $my_command"
	}
    }

    reload_structure

    editor-message "loaded $currentfile.$savenum"
}

proc reload_structure {} {
    global savenum newest_node last_text_node_id
    reset-rst

    if { $savenum > 0 } {
	load-rst $savenum
	set newest_node $last_text_node_id
    }
    reestablish
}
